package net.umc.ludumdare.states;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;

import net.umc.ludumdare.common.Projectile;
import net.umc.ludumdare.common.Sprite;
import net.umc.ludumdare.sprites.BlueShip;
import net.umc.ludumdare.sprites.BlueShot;
import net.umc.ludumdare.sprites.RedShip;
import net.umc.ludumdare.sprites.Ship;
import net.umc.ludumdare.sprites.YellowShip;
import net.umc.ludumdare.tools.ResourceManager;

import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.Input;
import org.newdawn.slick.SlickException;

import org.newdawn.slick.state.BasicGameState;
import org.newdawn.slick.state.StateBasedGame;

public class PlayState extends BasicGameState{

    int stateID = 2, bgPos = 500;
    private Ship ship;
    private Image spacebg;
    private ArrayList<BlueShot> shots;
    private ArrayList<Projectile> enemies;
    private int screenWidth, screenHeight;
    private int shipVelX = 4, shipVelY = 3, count = 0, invincible = 10;
    public static int lives = 3, score = 0;
    private Random random;
    
    public PlayState( int stateID ) 
    {
       this.stateID = stateID;
    }
 
    public int getID() {
        return stateID;
    }
 
    public void init(GameContainer gc, StateBasedGame sbg) throws SlickException {
    	ship = new Ship();
    	ship.x = ship.y = 10;
    	ship.width = ship.height = 64;
    	screenWidth = ResourceManager.getGlobalInt("SCREEN_WIDTH");
    	screenHeight = ResourceManager.getGlobalInt("SCREEN_HEIGHT");
    	spacebg = ResourceManager.getImage("space_bg");
    	shots = new ArrayList<BlueShot>();
    	enemies = new ArrayList<Projectile>();
    	random = new Random();
    }
 
    public void render(GameContainer gc, StateBasedGame sbg, Graphics g) throws SlickException {
    	// background
    	g.drawImage(spacebg, bgPos, 0);
    	g.drawImage(spacebg, bgPos, 500);
    	g.drawImage(spacebg, bgPos+500, 0);
    	g.drawImage(spacebg, bgPos+500, 500);
    	g.drawImage(spacebg, bgPos-500, 0);
    	g.drawImage(spacebg, bgPos-500, 500);
    	
    	// projectiles
    	for(BlueShot bs: shots) {
    		bs.render(gc, sbg, g);
    	}
    	
    	for(Projectile p: enemies){
    		p.render(gc, sbg, g);
    	}
    	
    	// game play
    	if (invincible == 0 || invincible % 2 == 0)
    		ship.render(gc, sbg, g);
    	else
    		ship.render(gc, sbg, g, true);
    	
    	// HUD
    	//g.drawImage(ResourceManager.getImage("ship16"), 100, 10);
    	for (int i = lives - 1; i > 0; i--)
    		g.drawImage(ResourceManager.getImage("ship32"), 150 + (36 * i), 10);
    	g.drawString("Score: " + score, 700, 10);
    }
 
    public void update(GameContainer gc, StateBasedGame sbg, int delta) throws SlickException {
    	Input input = gc.getInput();
    	
    	if (ship.dead) {
    		invincible = 50;
    		ship.dead = false;
    		ship.x = 400;
    		ship.y = 300;
    	}
    	
    	HashSet<Integer> shotsToRemove = new HashSet<Integer>();
    	HashSet<Integer> enemiesToRemove = new HashSet<Integer>();
    	for(int i = shots.size() - 1; i >= 0; i--) {
    		if (shots.get(i).dead || shots.get(i).x >= screenWidth) {
    			shotsToRemove.add(i);
    		}
    		else {
    			shots.get(i).update(gc, sbg, delta);
    		}
    	}
    	
    	for(int i = enemies.size() - 1; i >= 0; i--) {
    		boolean collided = false;
    		if (enemies.get(i).dead || enemies.get(i).x + enemies.get(i).width < 0 || 
    				enemies.get(i).y + enemies.get(i).height < 0) {
    			enemiesToRemove.add(i);
    		}
    		else {
    			enemies.get(i).update(gc, sbg, delta);
    			for (int j = shots.size() - 1; j >= 0; j--) {
    				if (collides(enemies.get(i), shots.get(j))) {
    					enemies.get(i).collides(gc, sbg, delta);
    					shots.get(j).collides(gc, sbg, delta);
    					collided = true;
    					break;
    				}
    			}
    		}
    		if (collided) continue;
    		if (invincible > 0) {
    			invincible--;
    			continue;
    		}
    		if (collides(ship,enemies.get(i))) {
    			ship.collides(gc, sbg, delta);
    			//invincible = 10;
    			ship.dead = true;
    			lives--;
    			enemies.get(i).collides(gc, sbg, delta);
    		}
    	}
    	
    	for(Integer idx: shotsToRemove.toArray(new Integer[shotsToRemove.size()])) {
    		shots.remove(shots.get(idx));
    	}
    	
    	for(Integer idx: enemiesToRemove) {
    		enemies.remove(enemies.get(idx));
    	}
    	
    	if (input.isKeyPressed(Input.KEY_SPACE)) {
    		ResourceManager.getSound("blop").play();
    		if (shots.size() < 5) {
    			shots.add(new BlueShot(ship.x + ship.width - 50, ship.y + (ship.height/2)));
    		}
    	}
    	
    	if (input.isKeyDown(Input.KEY_LEFT)) {
    		if (ship.x > 0) ship.x -= shipVelX;
    	}
    	else if (input.isKeyDown(Input.KEY_RIGHT)) {
    		if (ship.x + ship.width < screenWidth) ship.x += shipVelX;
    	}
    	
    	if (input.isKeyDown(Input.KEY_UP)) {
    		if (ship.y > 0) ship.y -= shipVelY;
    	}
    	else if (input.isKeyDown(Input.KEY_DOWN)) {
    		if (ship.y + ship.height < screenHeight) ship.y += shipVelY;
    	}
    	
    	bgPos = bgPos > 0 ? bgPos - 2 : 500;
    	
    	count++;
    	
    	if (count % 270 == 0) {
    		enemies.add(new BlueShip(790, random.nextInt(600)));
    	}
    	else if (count % 180 == 0) {
    		enemies.add(new RedShip(random.nextInt(800), 590));
    	}
    	else if (count % 90 == 0) {
    		if (random.nextInt(2) % 2 == 0) {
    			enemies.add(new YellowShip(random.nextInt(800), 59));
    		}
    		else {
    			enemies.add(new YellowShip(790, random.nextInt(600)));
    		}
    	}
    	//System.out.println(count);
    }
	
    private boolean collides(Sprite a, Sprite b) {
    	if (a.x + a.width < b.x) {
    		return false;
    	}
    	else if (a.x > b.x + b.width) {
    		return false;
		}
    	else if (a.y + a.height < b.y) {
			return false;
		}
    	else if (a.y > b.y + b.height) {
			return false;
		}
    	return true;
    }
}
